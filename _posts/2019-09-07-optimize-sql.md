---
title:  "SQL优化"
date:   2019-09-07 12:00:00 +0800
categories: [database]
---

# 功能性表

## 全局临时表

如果数据是临时的，也就是说用完即抛，需要频繁执行删除操作（删除操作会造成大量日志写入，占用服务） 

## 分区表

分区表可以包括多个分区， 每个分区都是一个独立的段（ SEGMENT），可以存放到不同的表空间中 。查询时可以通过查询表来访问各个分区中的数据，也可以通过在查询时直接指定分区的方法来进行查询

* 由于将数据分散到各个分区中，减少了数据损坏的可能性；
* 可以对单独的分区进行备份和恢复；
* 可以将分区映射到不同的物理磁盘上，来分散IO；
* 提高可管理性、可用性和性能。

# 索引

## 类型

* 主键：一种特殊的唯一索引，不允许有空值。
* 唯一键:索引列的值必须唯一，但允许有空值。
* 普通
* 组合（最左前缀）:为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。创建复合索引时应该将最常用（频率）作限制条件的列放在最左边，依次递减。组合索引最左字段用in是可以用到索引的。

<!--more-->

## 聚集索引

* 聚集索引：索引中键值的逻辑顺序决定了表中相应行的物理顺序（索引中的数据物理存放地址和索引的顺序是一致的）。
* 非聚集索引：索引的逻辑顺序与磁盘上的物理存储顺序不同。
  
Inno DB的聚集索引规则：

* 如果一个主键被定义了，那么这个主键就是作为聚集索引
* 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引
* 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。

# 共享池优化

## 绑定变量，节省解析时间

排查方式：
* awr报表
* trace
  ```sql
  overall totals for all recursive statements
  ```

反例：

* 影响SQL索引选择
  ``` sql
  select count(*) from t where id < 990;  -- 全表
  select count(*) from t where id < 10;   -- 索引
  select count(*) from t where id < :id;  -- 不做优化，一直使用索引
  ```

# 数据缓冲

# 日志优化

* 事务提交需要写日志，批处理减小日志的性能损耗

# Oracle逻辑体系结构

```
logical : database --> table space --> segment --> extent --> data block
physical:              data file               -->            OS block
```

![ oracle logic data structure ]({{ "/assets/2019-09-07-1.png" | absolute_url }})

## 最小单位block

* 数据块头（类型，地址，归属segment）
* 表目录（某行数据插入到块中，该行数据所在表的信息）
* 行目录（行地址）
* 可用空间（剩余空间；若是表或索引块，会存放事物条目）
* 行数据区（行或索引的信息）
  
### 一个block能装多少行？

各种开销导致，每行最小长度大致是11字节，例如，一个8k块理论上最多存储不超过8096/11行

### 行迁移

* 成因：当行update时，若update更新的行大于数据库的pctfree（可用空间）就需要申请新的块，从而形成迁移
* 后果：导致应用需要更多的快，性能下降
* 预防：pctfree调大；块调大
* 检查：
  ```sql
  analyze table <table name> validate structure cascade into chained_rows
  ```

# 优化点总结

* 减少不必要的方法调用，缩小调用方法的次数
* 批操作能提升性能
* 只取需要的列（只用索引无需回表；只用索引连表速度变快）
* 使用绑定变量，减少硬解析次数
* 功能性表选取，临时表或分段表
* 索引优化

