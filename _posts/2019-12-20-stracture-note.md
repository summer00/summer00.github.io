---
title: "从零开始学架构--读书笔记"
date: 2019-12-20 12:00:00 +0800
categories: [book-note]
---

本篇为我阅读[《从零开始学架构》](https://book.douban.com/subject/33425123/)的读书笔记。如觉得有帮助，请购买正版图书学习。

- [高性能存储](#高性能存储)
  - [关系型数据库](#关系型数据库)
    - [数据库范式](#数据库范式)
    - [读写分离](#读写分离)
    - [业务分库](#业务分库)
    - [分表](#分表)
    - [唯一主键生成](#唯一主键生成)
  - [NoSQL](#nosql)
    - [K-V 存储（Redis 为例）](#k-v-存储redis-为例)
    - [文档数据库](#文档数据库)
    - [列式数据库](#列式数据库)
    - [全文搜索引擎](#全文搜索引擎)
  - [缓存](#缓存)
    - [CDN 缓存静态资源](#cdn-缓存静态资源)
  - [消息队列](#消息队列)
    - [作用](#作用)
    - [消息丢失](#消息丢失)
    - [消息重复消费](#消息重复消费)
    - [消息延迟](#消息延迟)
    - [Kafka 设计优点](#kafka-设计优点)
- [计算高性能](#计算高性能)
  - [单机高性能](#单机高性能)
    - [PPC(Process per Connection)](#ppcprocess-per-connection)
    - [pre-fork](#pre-fork)
    - [TPC(Thread per Connection)](#tpcthread-per-connection)
    - [pre-thread](#pre-thread)
    - [Reactor(Dispatcher)](#reactordispatcher)
    - [Proactor](#proactor)
  - [集群高性能](#集群高性能)
    - [负载均衡](#负载均衡)
- [CAP](#cap)
  - [解释：](#解释)
  - [应用](#应用)
  - [ACID 和 BASE](#acid-和-base)
- [基础篇](#基础篇)
  - [通用设计方法](#通用设计方法)
    - [系统演进思路：](#系统演进思路)
  - [架构分层](#架构分层)
    - [分层的好处：](#分层的好处)
    - [分层的坏处：](#分层的坏处)
    - [如何分层：](#如何分层)
  - [系统设计目标](#系统设计目标)
    - [高性能](#高性能)
    - [高可用（系统具备较高的无故障运行的能力）](#高可用系统具备较高的无故障运行的能力)
    - [高可扩展](#高可扩展)
- [分布式](#分布式)
  - [分布式改造的原因](#分布式改造的原因)
  - [服务拆分](#服务拆分)
  - [问题和解决](#问题和解决)
  - [注册中心](#注册中心)
  - [链路追踪](#链路追踪)
  - [客户端负载均衡](#客户端负载均衡)
  - [API网关](#api网关)

# 高性能存储

## 关系型数据库

### 数据库范式

1. 每个属性都不可再分。即每个列不可再分。1NF 是所有关系型数据库的最基本要求。
2. 表中的每列都和主键相关。一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
3. 每一列数据都和主键直接相关，而不能间接相关。

### 读写分离

- 主从模式（一主多从，多主多从），数据写如主库，从库复制主库数据，分担读压力。
- 问题
  - 延迟：主从复制需要时间，可能造成延迟。解决方法：
    1. 写操作后的读，发送给主库
    2. 从库读取不到时，读取主库（二次读取）
    3. 关键业务（延迟要求低业务）全部从主库读取，非关键业务从库读取
  - 数据还是单机存储，当数据越来越多时，读写性能下降，备份话的时间更长，极端情况下丢失风险越大
- MySQL 是通过 binglog（保持在磁盘上的二进制日志）实现的，主库异步的将 binglog 传给从库，从库收到后解析成 SQL 在自己执行

### 业务分库

- 按照业务模块将数据分散到不同的数据库
- 建议：如果没有性能上的瓶颈就暂时不做分库；如果做一次做到位
- 问题：
  - join：原本可以通过 join 得到的结果，需要更复杂的实现（先查询 id，再根据 id 查询内容）
  - 事务：不同数据库中的表，可能在同一个操作中被修改（MySQL 分布式事务解决方案：XA）
  - 成本：需要更多机器支持分库，因此是否分库需要正确评估

### 分表

- 垂直分表：将原本一张表的内容写入多张表中，加快单表读写性能，读取完整数据可能更复杂
- 水平分表：将一张表（千万级别）的数据存储于多张表中，问题：
  - 路由：水平分表后，需要确定一条数据属于哪个子表，需增加路由算法。常见的路由有：范围，hash，配置
  - join：需要在业务代码或数据库中间件中进行多次 join 查询，然后合并结果
  - count：多次 count，或使用计数表（可能造成数据不一致，增加写压力）
  - group by：需要在业务代码或数据库中间件中进行排序
  - 无分区键字段查询：维护额外的分区键与查询字段的关系表

### 唯一主键生成

1. Snowflake：
   1. 特点：调递增，包含机器 ID、序列号、时间戳。
   2. 使用：可以嵌入代码中，也可以部署单独的 ID 服务器。
   3. 缺点：依赖系统的时间戳，如果时间不准会产生重复 ID；并发不高时，可能造成 ID 分布不均，可以用秒做结束，或者随机一个开始序号

## NoSQL

### K-V 存储（Redis 为例）

支持`string, hash, list, set, zset, map`

缺点：不完全支持 ACID

- 原子性：事务支持不完善
- 一致性：事务支持不完善
- 独立性：单线程，事务过大会阻塞
- 持久性：RDB 和 AOF

### 文档数据库

为了解决 schema 带来的问题，最大的特点是灵活无 schema，大部分使用 json 存储数据。适合与电商游戏等场景。可作为关系型数据库的补充。

优势：

- 新增字段简单
- 历史数据不会出错
- 可以很容易存储复杂数据

缺点：

- 不支持事务
- join 麻烦

### 列式数据库

一般将列式存储应用在离线的大数据分析和统计场景中，因为这种场景通常在几个列中，且不需更新删除数据。

优势：

- 在只需要几个值的情况下，可直接读出，节省 IO
- 压缩比例高

缺点：

- 当同时需要多个列时，效率较低。因为要更新需要将存储的数据解压后更新，再压缩，最后写入磁盘

### 全文搜索引擎

传统关系型数据库可能无法满足全文搜索的需求场景，因为全文搜索的条件通常是任意组合的，如果建索引需要建很多；like 是整表扫描，效率非常底

全文搜索通常使用倒排索引实现，原理是建立单词到文档的索引。

## 缓存

问题：

- 缓存穿透：指缓存没有发生作用，虽然去查询了缓存，但缓存中没有数据，再次访问存储系统
  - 原因：1）数据不存在；2）生产缓存需要大量的运算
  - 解决：解决 1）没有查询到的值设置默认值；解决 2）监控
- 缓存雪崩：当缓存失效后，引起的系统大面积的性能下降
  - 解决：更新锁，对缓存更新进行加锁保护；后台更新，由特定的后台线程完成缓存定时更新操作，此时也可能由于缓存占满导致缓存失效，此时可使用定时读取或消息队列通知的形式通知后台线程更新缓存
- 缓存热点：当大多数查询同时命中缓存时可能造成缓存服务器压力较大
  - 解决：多缓存几份

### CDN 缓存静态资源

CDN 就是将静态的资源分发到位于多个地理位置机房中的服务器上，因此它能很好地解决数据就近访问的问题，也就加快了静态资源的访问速度。

以 www.baidu.com 为例给你简单的域名解析过程：

1. 域名解析请求先会检查本机的 hosts 文件，查看是否有 www.baidu.com 对应的 IP；
2. 如果没有的话，就请求 Local DNS 是否有域名解析结果的缓存，如果有就返回标识是从非权威 DNS 返回的结果；
3. 如果没有就开始 DNS 的迭代查询。先请求根 DNS，根 DNS 返回顶级 DNS（.com）的地址；再请求.com 顶级 DNS 得到 baidu.com 的域名服务器地址；再从 baidu.com 的域名服务器中查询到 www.baidu.com 对应的 IP 地址，返回这个 IP 地址的同时标记这个结果是来自于权威 DNS 的结果，同时写入 Local DNS 的解析结果缓存，这样下一次的解析同一个域名就不需要做 DNS 的迭代查询了。

## 消息队列

### 作用

1. 削峰填谷，将峰值流量缓存在消息队列中，如秒杀场景
2. 异步处理，处理非主要流程，如消费后发放优惠卷
3. 解耦，不直接依赖接口，依赖消息队列降低系统间的耦合型

### 消息丢失

1. 生产者发送消息时网络错误，以为发送给了 MQ，实际 MQ 没有接收到。这种情况设置正确的消息重传次数和失败处理，另外也可以设置消息同步到多个副本才算成功。
   - 设置副本数大于 1
   - 设置活跃 follower 大于 1
   - 设置 leader 需要把消息同步到最小活跃同步 follower 才算写入成功
   - 重试次数和处理设置
2. MQ 仅接收到消息，还未来得及写入磁盘保存；只写入到 leader 没有同步到 follower 时，leader 挂了
   - 设置副本数大于 1
   - 设置活跃 follower 大于 1
   - 设置 leader 需要把消息同步到最小活跃同步 follower 才算写入成功
   - 重试次数和处理设置
3. 消费者已经提交了确认，但消费途中没有处理完就 down 了 --> 关闭自动提交确认，手动保证处理完成后提交

### 消息重复消费

避免重复消费，需要保证消息的生产、消费过程的幂等性：

- 生产幂等性有多种 MQ 都支持，MQ 做法是给每一个生产者一个唯一的 ID，并且为生产的每一条消息赋予一个唯一 ID，消息队列的服务端会存储 < 生产者 ID，最后一条消息 ID> 的映射。当某一个生产者产生新的消息时，消息队列服务端会比对消息 ID 是否与存储的最后一条 ID 一致，如果一致就认为是重复的消息，服务端会自动丢弃
- 消费者通过鉴定唯一 ID 是否已经消费过保证。可以用数据库保证，需要整个处理过程在同一个事务中。也可以用乐观锁保证，比如给数据添加版本号。

### 消息延迟

1. 监控：
   1. 使用消息队列提供的工具，通过监控消息的堆积来完成，如`kafka-consumer-groups.sh`、`JMX`
   2. 生成监控消息的方式来监控消息的延迟情况，具体是生成一个时间戳消息，消费者消费到此消息时判断时间是否大于阈值，发送报警
2. 减少的方法：
   1. 优化消费性能
   2. 增加消费者数量（Kafka 消费者的数量和分区数一样，需要同时增加分区数和消费者数）

### Kafka 设计优点

1. Kafka 使用硬盘存储，但做了很多优化的设计使存储性能很高
   1. 顺序存储，所有的消息在文件后面追加
   2. 通过维护一个 offset 来实现顺序访问
2. IO 采用 0 拷贝技术，减少了从内核空间读取到用户缓存，再从用户缓存输出到网络流的时间。直接从页缓存写入网络流
3. 网络带宽上的设计考虑，会对消息做压缩，减少带宽消耗。也可以设置消息批量发送，减少网络请求次数
4. 分布式存储设计，有备份和主分区，保证消息不丢失。用户通过 offset 也能从宕机事故中快速恢复

<!--more-->

# 计算高性能

高性能计算有两个角度：1）提高单机计算能力；2）若单机无法支撑，设计服务集群方案

## 单机高性能

单机高性能与服务器采用的网络编程模型有关：服务器如何管理连接；服务器如何处理请求。

### PPC(Process per Connection)

每次有新的连接就建立一个线程去处理。适合服务器的连接数没那么多的情况。

缺点：

- 进程建立代价高
- 父子进程通信复杂
- 进程数量增多后系统压力打

### pre-fork

提前创建进程，节约创建进程的时间，但与 PPC 没有太大区别，有同样问题

### TPC(Thread per Connection)

每次请求新建进程处理，线程更轻量极，通信也更简单

缺点：引入了一些新问题

- 线程也有代价
- 线程间通信问题
- 某个线程异常会导致进程退出，没那么稳定

### pre-thread

预先创建线程，节约时间。

### Reactor(Dispatcher)

资源复用，不再为每个连接创建进程，而是创建进程池。引入 I/O 多路复用概念，增加吞吐量。

多路复用技术要点：

1. 当多条连接共用一个阻塞对象时，进程只需在一个阻塞对象上等待，无需轮寻
2. 当某个连接有数据可以处理时，唤醒进程，开始处理

实现方式：

1. 单 Reactor 单进程/线程（Redis）
2. 单 Reactor 多线程（Java NIO）
3. 多 Reactor 多进程/线程（Nginx，Memcache，Netty）

### Proactor

异步网络模型（AIO）

## 集群高性能

### 负载均衡

分类：

1. DNS：解析同一个域名可以返回不同的 IP（按地区访问不同的服务）
   1. 优点：便宜简单；就近访问
   2. 缺点：更新不及时，缓存；拓展性能差；分配策略简单
2. 硬件负载均衡：基础网络设备，F5,A10
   1. 优点：功能性能强大；稳定性高；支持安全防护
   2. 缺点：贵，拓展差
3. 软件负载均衡：Nginx（7 层），LVS（4 层）
   1. 优点：简单，便宜，灵活
   2. 缺点：性能一般；不具有安全功能

以上三种互相结合使用，DNS 转发区域请求，F5 负责区域集群请求，Nginx 用于机器级别

算法：轮寻；加权轮寻；负载低优先；性能最优；hash

# CAP

一个分布式系统中，当涉及读写操作时，只能保证一致性（Consistence)、可用性(Availability)、分区容错性(Partition Tolerance)三者中的两个。

## 解释：

- Consistence：某个节点能读到最新的写结果
- Availability：非故障节点能在合理时间内返回合理结果
- Partition Tolerance: 当网络分区后，系统能继续履行职责

## 应用

真实情况是 P 必须被选择，因为网络不稳定。所以可选择 AP 或者 CP。

在设计时需要注意：

1. 粒度是数据，而不是系统。系统中的某些数据可能需要 AP，某些可能需要 CP
2. CAP 忽略了网络延迟。但在数据同步中可能因网络延迟造成不一致，所以强一致性要求的话，需要保证 CA，放弃 P，即单点写入，其他节点备份。这时可使用如用户分区之类的方法，减小 P 缺失带来的影响。
3. 正常情况下，可以同时满足 CA
4. 放弃并不意味着什么都不做，需要为恢复做准备。如可用分区日志进行数据恢复，也可以一定规则恢复数据。

## ACID 和 BASE

ACID：数据库事物：原子性，一致性，隔离性，持久性
BASE（AP 方案的衍生）：基本可用，软状态，最终一致性

<hr/>

以下是高并发系统设计学习笔记。

- 在微博中，明星动辄拥有几千万甚至上亿的粉丝，你要怎么保证明星发布的内容让粉丝实时地看到呢？
- 淘宝双十一，当你和上万人一起抢购一件性价比超高的衣服时，怎么保证衣服不会超卖？
- 春运时我们都会去 12306 订购火车票，以前在抢票时经常遇到页面打不开的情况，那么如果你来设计 12306 系统，要如何保证在千万人访问的同时也能支持正常抢票呢？

# 基础篇

## 通用设计方法

1. Scale-out（横向拓展）：突破单机计算瓶颈
2. 缓存：降低响应时间的中间存储
3. 异步：削峰填谷，减小服务器压力，收发更多请求

### 系统演进思路：

- 最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系
- 随着流量的增加和业务的变化修正架构中存在问题的点，如单点问题、横向扩展问题、性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件帮助我们解决问题，在社区没有合适解决方案的前提下才会自己造轮子
- 当对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有的问题

## 架构分层

### 分层的好处：

1. 简化系统设计，让不同的人专注做某层的事情
2. 可以提高复用性，不同的上层项目可以依赖相同的中间层或基础层
3. 可以方便横向拓展，只用拓展某一层

### 分层的坏处：

1. 引入复杂性
2. 性能损耗

### 如何分层：

三层架构模型：表现层、业务逻辑层、数据访问层

细化三层架构：终端显示层、开放接口层（提供给外部的开放接口）、web 层（访问控制进行转发，校验、不复用的业务简单处理）、业务逻辑层、通用业务层（原子化、通用服务）、数据访问层、外部接口或第三方平台

DDD（领域驱动设计）

## 系统设计目标

### 高性能

原则：

1. 不能盲目，问题导向
2. 抓住主要矛盾，优先优化主要的性能瓶颈
3. 性能优化要有数据支持，要时刻了解你的优化让响应减少了多少，提升了多少吞吐量
4. 持续优化

指标：

1. 平均值：均值可以在一定程度上反应这段时间的性能，但它敏感度比较差，如果这段时间有少量慢请求时，在平均值上并不能如实地反应。平均值对于度量性能来说只能作为一个参考。
2. 最大值：这段时间内所有请求响应时间最长的值，但它的问题又在于过于敏感了。
3. 分位值：分位值有很多种，比如 90 分位、95 分位、75 分位。一共有 100 个请求，那么排在第 90 位的响应时间就是 90 分位值。分位值排除了偶发极慢请求对于数据的影响，能够很好地反应这段时间的性能情况，分位值越大，对于慢请求的影响就越敏感。
4. 吞吐量和响应时间：度量性能时都会同时兼顾吞吐量和响应时间，比如设立性能优化的目标时通常会这样表述：在每秒 1 万次的请求量下，响应时间 99 分位值在 10ms 以下。

优化：

1. 硬件优化（CPU、内存），有拐点，压测可以找到拐点
2. CPU 密集型，优化算法
3. IO 密集型，找到系统瓶颈，逐个击破

### 高可用（系统具备较高的无故障运行的能力）

度量：

1. MTBF（Mean Time Between Failure）是平均故障间隔的意思，代表两次故障的间隔时间，也就是系统正常运转的平均时间。这个时间越长，系统稳定性越高
2. MTTR（Mean Time To Repair）表示故障的平均恢复时间，也可以理解为平均故障时间。这个值越小，故障对于用户的影响越小。
3. Availability = MTBF / (MTBF + MTTR)。可用性可以几个九来描述系统的可用性。四个九要建立完善的值班体系、故障处理流程和业务变更流程；五个九要建立自动的恢复机制和容灾能力。

高可用设计思路：

1. 系统设计：高可用系统设计的第一原则是“Design for failure”，故障在庞大集群中总是存在的。具体方法有：故障转移、超时控制、降级、限流
2. 系统运维：灰度发布、故障演练

### 高可扩展

提高可扩展性的方式的重要思路是拆分。我们可以按照业务区域对系统进行拆分，使不同业务直接更加独立，可以单独扩展。

# 分布式

## 分布式改造的原因

1. 系统中使用的资源出现拓展性问题，尤其是数据库
2. 大团队共同维护一套代码，效率降低、成本提升
3. 系统部署成本增加

## 服务拆分

1. 单一服务内部功能的高内聚和低耦合
2. 关注服务拆分的粒度，先粗略拆分再逐渐细化。拆分初期可以把服务粒度拆得粗一些，后面随着团队对于业务和微服务理解的加深，再考虑把服务粒度细化
3. 拆分的过程，要尽量避免影响产品的日常功能迭代。可以逐步拆分，先拆分独立、边缘服务；存在依赖关系的先拆分被依赖的服务
4. 服务接口定义要具备可扩展性，可以封装参数是类，或者采用版本管理，逐步替换方式

## 问题和解决

1. 服务治理，服务的部署信息统一管理 --> 注册中心
2. 一个服务可能被多个其他服务使用，一旦发生性能问题，造成整个系统问题 --> 融断、降级、限流、超时控制
3. 调用链变长，问题难以排查 --> 链路追踪

## 注册中心

功能：提供服务地址的存储；当一个服务端的地址发生变化后通知其他客户端

服务状态管理实现：

1. 主动探测，注册中心定时调用接口判断服务是否可用。这种方式服务数量上升后轮寻调用成本增高。
2. 心跳模式，节点定时发送心跳包给注册中心，如果长时间未收到心跳包，表示节点不可用。

问题：

1. 节点过度摘除：注册中心可以添加一些保护措施，比如当移除的节点超过所有节点的 40%停止移除，发送报警，此时考虑是网络问题或服务中心本身问题。
2. 通知风暴：当管理集群过大时，节点状态的同步消息就需要发送给更多节点。可以采用扩展注册中心；注意注册中心流量，控制管理集群规模；保护机制

## 链路追踪

问题排查、性能瓶颈查找

可以通过在日志中加入请求 id`requestId`，下一跳 id`spanId`来跟踪请求，每次请求将它们作为参数传递。日志可以采用采样打印方式防止过度性能消耗，日志可以先发送给 MQ 提高写入效率。

## 客户端负载均衡

在客户端选择要调用的服务端，通常会结合注册中心一起使用。

常用策略有：静态策略：轮寻、带权重轮寻；动态策略：优先选择活跃连接数最少服务；加响应时间权重分配

## API网关

API 网关（API Gateway）不是一个开源组件，而是一种架构模式，它是将一些服务共有的功能整合在一起，独立部署为单独的一层，用来解决一些服务治理的问题。你可以把它看作系统的边界，它可以对出入系统的流量做统一的管控。

网关的实现重点在于性能和拓展性，可以用多路I/O复用模型和线程池并发处理，来提升系能，使用责任链模式来提升网关的拓展性。为防止某服务处理时间过长或者故障，占有所有网关线程资源，可以考虑给不同的服务专属线程池，或者限制服务占用线程池的大小。

- 入口网关：
  - 提供给客户端统一的接入地址，将请求动态路由到不同业务的服务，并且可以做一些转换工作
  - 植入一些服务治理的策略，如服务的熔断、降级、流量控制和分流
  - 客户端认证和授权
  - 黑白名单，比如针对设备 ID、用户 IP、用户 ID 等维度的黑白名单
  - 日志记录，链路追踪
- 出口网关
  - 系统依赖第三方服务，可以用出口网关提供统一的介入方式