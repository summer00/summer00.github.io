---
title:  "从零开始学架构--读书笔记"
date:   2019-12-20 12:00:00 +0800
categories: [book-note]
---

本篇为我阅读[《从零开始学架构》](https://book.douban.com/subject/33425123/)的读书笔记。如觉得有帮助，请购买正版图书学习。

- [高性能存储](#高性能存储)
  - [关系型数据库](#关系型数据库)
    - [读写分离](#读写分离)
    - [业务分库](#业务分库)
    - [分表](#分表)
  - [NoSQL](#nosql)
    - [K-V存储（Redis为例）](#k-v存储redis为例)
    - [文档数据库](#文档数据库)
    - [列式数据库](#列式数据库)
    - [全文搜索引擎](#全文搜索引擎)
  - [缓存](#缓存)
- [计算高性能](#计算高性能)
  - [单机高性能](#单机高性能)
    - [PPC(Process per Connection)](#ppcprocess-per-connection)
    - [pre-fork](#pre-fork)
    - [TPC(Thread per Connection)](#tpcthread-per-connection)
    - [pre-thread](#pre-thread)
    - [Reactor(Dispatcher)](#reactordispatcher)
    - [Proactor](#proactor)
  - [集群高性能](#集群高性能)
    - [负载均衡](#负载均衡)
- [CAP](#cap)
  - [解释：](#解释)
  - [应用](#应用)
  - [ACID 和 BASE](#acid-和-base)

# 高性能存储

## 关系型数据库

### 读写分离

* 主从模式（一主多从，多主多从），数据写如主库，从库复制主库数据，分担读压力。
* 问题
  * 延迟：主从复制需要时间，可能造成延迟。解决方法：
    1. 写操作后的读，发送给主库
    2. 从库读取不到时，读取主库（二次读取）
    3. 关键业务（延迟要求低业务）全部从主库读取，非关键业务从库读取
  * 数据还是单机存储，当数据越来越多时，读写性能下降，备份话的时间更长，极端情况下丢失风险越大 
    * 分库

### 业务分库

* 按照业务模块将数据分散到不同的数据库
* 问题：
  * join：原本可以通过join得到的结果，需要更复杂的实现（先查询id，再根据id查询内容）
  * 事务：不同数据库中的表，可能在同一个操作中被修改（MySQL分布式事务解决方案：XA）
  * 成本：需要更多机器支持分库，因此是否分库需要正确评估

### 分表

* 垂直分表：将原本一张表的内容写入多张表中，加快单表读写性能，读取完整数据可能更复杂
* 水平分表：将一张表（千万级别）的数据存储于多张表中，问题：
  * 路由：水平分表后，需要确定一条数据属于哪个子表，需增加路由算法。常见的路由有：范围，hash，配置
  * join：需要在业务代码或数据库中间件中进行多次join查询，然后合并结果
  * count：多次count，或使用计数表（可能造成数据不一致，增加写压力）
  * group by：需要在业务代码或数据库中间件中进行排序

## NoSQL

### K-V存储（Redis为例）

支持`string, hash, list, set, zset, map`

缺点：不完全支持ACID
* 原子性：事务支持不完善
* 一致性：事务支持不完善
* 独立性：单线程，事务过大会阻塞
* 持久性：RDB和AOF

### 文档数据库

为了解决schema带来的问题，最大的特点是灵活无schema，大部分使用json存储数据。适合与电商游戏等场景。可作为关系型数据库的补充。

优势：
* 新增字段简单
* 历史数据不会出错
* 可以很容易存储复杂数据

缺点：
* 不支持事务
* join麻烦

### 列式数据库

一般将列式存储应用在离线的大数据分析和统计场景中，因为这种场景通常在几个列中，且不需更新删除数据。

优势：
* 在只需要几个值的情况下，可直接读出，节省IO
* 压缩比例高

缺点：
* 当同时需要多个列时，效率较低。因为要更新需要将存储的数据解压后更新，再压缩，最后写入磁盘

### 全文搜索引擎

传统关系型数据库可能无法满足全文搜索的需求场景，因为全文搜索的条件通常是任意组合的，如果建索引需要建很多；like是整表扫描，效率非常底

全文搜索通常使用倒排索引实现，原理是建立单词到文档的索引。

## 缓存

问题：
* 缓存穿透：指缓存没有发生作用，虽然去查询了缓存，但缓存中没有数据，再次访问存储系统
  * 原因：1）数据不存在；2）生产缓存需要大量的运算
  * 解决：解决1）没有查询到的值设置默认值；解决2）监控
* 缓存雪崩：当缓存失效后，引起的系统大面积的性能下降
  * 解决：更新锁，对缓存更新进行加锁保护；后台更新，由特定的后台线程完成缓存定时更新操作，此时也可能由于缓存占满导致缓存失效，此时可使用定时读取或消息队列通知的形式通知后台线程更新缓存
* 缓存热点：当大多数查询同时命中缓存时可能造成缓存服务器压力较大
  * 解决：多缓存几份

<!--more-->

# 计算高性能

高性能计算有两个角度：1）提高单机计算能力；2）若单机无法支撑，设计服务集群方案

## 单机高性能

单机高性能与服务器采用的网络编程模型有关：服务器如何管理连接；服务器如何处理请求。

### PPC(Process per Connection)

每次有新的连接就建立一个线程去处理。适合服务器的连接数没那么多的情况。

缺点：
* 进程建立代价高
* 父子进程通信复杂
* 进程数量增多后系统压力打

### pre-fork

提前创建进程，节约创建进程的时间，但与PPC没有太大区别，有同样问题

### TPC(Thread per Connection)

每次请求新建进程处理，线程更轻量极，通信也更简单

缺点：引入了一些新问题
* 线程也有代价
* 线程间通信问题
* 某个线程异常会导致进程退出，没那么稳定

### pre-thread

预先创建线程，节约时间。

### Reactor(Dispatcher)

资源复用，不再为每个连接创建进程，而是创建进程池。引入I/O多路复用概念，增加吞吐量。

多路复用技术要点：
1. 当多条连接共用一个阻塞对象时，进程只需在一个阻塞对象上等待，无需轮寻
2. 当某个连接有数据可以处理时，唤醒进程，开始处理

实现方式：
1. 单Reactor单进程/线程（Redis）
2. 单Reactor多线程（Java NIO）
3. 多Reactor多进程/线程（Nginx，Memcache，Netty）

### Proactor

异步网络模型（AIO）

## 集群高性能

### 负载均衡
分类：
1. DNS：解析同一个域名可以返回不同的IP（按地区访问不同的服务）
   1. 优点：便宜简单；就近访问
   2. 缺点：更新不及时，缓存；拓展性能差；分配策略简单
2. 硬件负载均衡：基础网络设备，F5,A10
   1. 优点：功能性能强大；稳定性高；支持安全防护
   2. 缺点：贵，拓展差
3. 软件负载均衡：Nginx（7层），LVS（4层）
   1. 优点：简单，便宜，灵活
   2. 缺点：性能一般；不具有安全功能

以上三种互相结合使用，DNS转发区域请求，F5负责区域集群请求，Nginx用于机器级别

算法：轮寻；加权轮寻；负载低优先；性能最优；hash

# CAP

一个分布式系统中，当涉及读写操作时，只能保证一致性（Consistence)、可用性(Availability)、分区容错性(Partition Tolerance)三者中的两个。

## 解释：
* Consistence：某个节点能读到最新的写结果
* Availability：非故障节点能在合理时间内返回合理结果
* Partition Tolerance: 当网络分区后，系统能继续履行职责

## 应用

真实情况是P必须被选择，因为网络不稳定。所以可选择AP或者CP。

在设计时需要注意：
1. 粒度是数据，而不是系统。系统中的某些数据可能需要AP，某些可能需要CP
2. CAP忽略了网络延迟。但在数据同步中可能因网络延迟造成不一致，所以强一致性要求的话，需要保证CA，放弃P，即单点写入，其他节点备份。这时可使用如用户分区之类的方法，减小P缺失带来的影响。
3. 正常情况下，可以同时满足CA
4. 放弃并不意味着什么都不做，需要为恢复做准备。如可用分区日志进行数据恢复，也可以一定规则恢复数据。

## ACID 和 BASE

ACID：数据库事物：原子性，一致性，隔离性，持久性
BASE（AP方案的衍生）：基本可用，软状态，最终一致性

