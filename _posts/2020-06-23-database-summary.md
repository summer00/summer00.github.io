---
title: "数据库总结"
date: 2020-06-22 18:00:00 +0800
categories: [database]
---

# 0.前言

数据库在软件开发中必不可少，是我日常生活中的小伙伴。狭义上的传统数据库是指关系型数据库，我常用 MySQL 和 Oracle。广义上讲数据库有：关系型、内存型（redis）、搜索引擎型（elasticsearch）、消息队列（kafka），只要是能够存储和获取数据的组件都可以称为数据库。本文是对数据库的一个总结，更好的串联知识，方便复习和回顾。

# MySQL

## 选型

MySQL 是关系型数据库的代表，简单易用，比起 Oracle 和 SQLServer 来说显得很轻量级。选择 MySQL 的原因：开源节约成本；使用广泛，技术成熟，维护成本低；性能不错。一般数据量不大，对 RTO（恢复时间目标）、RPO（恢复点目标） 要求不高，能够承受一定的数据损失时我会选用 MySQL。

## 部署

MySQL 一般会做高可用部署，常用有：简单的主从架构；MMM；MGR 等，[更多](https://juejin.im/post/5ca4b5dcf265da30bf15d096)。我们公司一开始采用简陋的主从，现在替换成了 MGR。另外，还有读写分离方式部署，专门设置读库减轻主节点压力。

MySQL 做主从复制主要是基于`binlog`日志完成的。主备之间是有延迟的，造成延迟的原因主要有：主备性能差异；备库执行其他耗时统计分析任务；大事务同步。切换时有两种方式：**可靠性优先**策略是等到主备延迟小于阈值（比如 3 分钟）将主库改为只读，之后等主备无延迟时，将备库改为可写，然后切换浏览；**可用性优先**是直接切换，之后通过 binglog 继续补延迟。

## 架构

MySQL 可分为 service 层和存储引擎层两个部分。

service 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。

### SQL 语句执行过程：

连接器建立连接、获取权限 --> 查询缓存（8.0 已废弃） --> 分析器 SQL 语句解析，检查语法错误 --> 优化器确定执行方案（如用什么索引、如何进行表连接） --> 执行器在会验证是否有权限，然后执行语句

# Oracle

实际上很多 MySQL 的设计都是参照 Oracle 进行的。由于公司 Oracle 运维水平高（花钱）所以当追求数据的安全性和稳定性时我会选择 Oracle。

## Oracle 语法与 MySQL 的差异

1. 主键：O 主键通过序列生成；M 有自增主键
2. 分页：O 分页比较复杂，没有 limit 语法，通过 row num 分页;M 有 limit 分页

# SQL 优化

## 索引

### 概念

- 索引类型：普通、唯一（可为空）、主键（唯一，不可为空）、组合（最左前缀原则）
- 索引模型：hash（仅等值查询）、有序数组（因为插入成本高仅适合静态存储引擎）、B+树（N 叉搜索树，减少树深度，减少磁盘读取）
- 聚集索引：
  - 聚集索引：索引中键值的逻辑顺序决定了表中相应行的物理顺序（索引中的数据物理存放地址和索引的顺序是一致的）。
  - 非聚集索引：索引的逻辑顺序与磁盘上的物理存储顺序不同
  - MySQL 是不是一定要有聚集索引：
    - 如果一个主键被定义了，那么这个主键就是作为聚集索引
    - 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引
    - 如果没有主键也没有合适的唯一索引，那么 innodb 内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个 6 个字节的列，改列的值会随着数据的插入自增。
- 覆盖索引：索引“覆盖了”我们的查询需求，我们称为覆盖索引。覆盖索引无需回表（回到主键索引树搜索的过程，我们称为回表），减少树的搜索次数。

### 优化

1. 若函数或者表达式子作为条件，无法使用索引，要避免
2. 利用好组合索引，利用最左前缀原则减少索引的创建，尽量使用覆盖索引减少回表，组合索引还需要注意字段的区分度
3. 当要查询的字段较长时，可创建前缀索引减少索引的消耗，要注意前缀索引的区分度
4. 主键选择：
   1. 最好是自增，插入时不会做过多的移动，减少页分裂、随机磁盘读写；也能使逻辑相邻的行在物理上也相邻，有利于内存缓存
   2. 尽量小，因为其他索引的叶子节点存的是主键，可以减小其索引大小

## 表结构

### 数据字段选取原则

- 更小的更好
  - 通常来说更小更快，占用的资源更少
  - 需要正确评估字段大小，在 schema 增加数据类型的范围是是很耗时和痛苦的操作
- 简单就好
  - 简单的数据类型操作通常需要更少的 CPU 周期
  - 例如，用内建日期类型存储时间，而不是字符串；不用整型存储 ip
- 尽量避免 NULL
  - NULL 列使存储、索引和比较都更为复杂
  - NULL 列存储需要更多空间，需要特殊处理
  - NULL 列为索引时，每个索引记录都需要记录一个额外的字节

### schema 设计中的陷阱

1. 太多列
2. 太多的关联：如 EAV 设计，MySQL 限制了每个关联操作最多只能有 61 张表，通常情况下单个查询最好控制在 12 个表以内。
3. 全能枚举：如 country enum('','0','1','2','3'....)
4. 变相枚举：如 is_default enum('Y', 'N')
5. Not invent here 的 null：用其他形式的特定值表示 null，造成不必要的复杂运算

## 其他

1. 特定写法：
   1. `count`：按照效率排序的话，`count(字段)` < `count(id)` < `count(1)` =. `count(*)`
   2. `join`：被驱动表上有索引时会使用**Index Nested-Loop Join**，驱动表扫描，被驱动表走索引树。小表做驱动表。被驱动表上没有索引时会使用**Block Nested-Loop Join**，将驱动表存入缓存中，被驱动表依次访问判断是否可以作为返回。当缓存足够大时是一样的，当缓存不够大时小表做驱动表更好。
   3. `order by`：尽量用上索引，如果是覆盖索引更好；如果需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大`sort_buffer_size`参数，来避免用到磁盘临时表；
2. 批量操作：事务提交需要写日志，批处理减小日志的性能损耗
3. 绑定变量，节约解析时间
4. 减少长事务

# 事务

事务特性：原子(atomicity)，一致性(consistency)，隔离性(isolation)，持久性(durability)

隔离级别：
| | 脏读 | 不可重复读 | 幻读 |
| ------------------------ | ---- | ---------- | ---- |
| read uncommitted | Y | Y | Y |
| read committed | N | Y | Y |
| repeatable read(default) | N | N | Y |
| serialized | N | N | N |

事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。当系统里没有比这个回滚日志更早的 read-view 的时候，才会删除回滚，所以长事务是有害的。

## 锁

按不同的方式分类锁可以划分为：

1. 粒度：行所、表锁、服务器锁
2. 功能：共享锁（读锁）、排他锁（写锁）、意向锁（简化加行级别锁后，再加别的锁时的检查）

避免死锁：

1. 如果事务涉及多个表，操作复杂，尽可能一次性锁定所有资源
2. 如果一次需要更新一个表中的很多数据，可以直接加表锁
3. 不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率
4. 设置合适的锁等待时间，MySQL InnoDB 中用`innodb_lock_wait_timeout`
5. 把最可能发生冲突的语句放在事务的最后

# ElasticSearch

ElasticSearch 是一个高性能的分布式搜索引擎。它存储数据的最小单位是 Document（文档），同一种类型的文档放在一个 Index（索引）中，Index 被存储在 Shard 上，Shard 分为 Primary Shard 和 Replica Shard，它们会分布在不同的 Node 上，提高数据的高可用。

## 倒排索引

倒排索引是维护的单词到文档 id 的关系，分为两个部分：

1. 单词词典：记录文档中的所有单词，记录单词到倒排列表的关系。可以用 B+树实现
2. 倒排列表：由倒排索引项组成（文档 ID、词频、位置（Position）、偏移（Offset）

## 设计优点：

1. API 设计的好，简洁易用
2. 分布式存储，每个索引可以设置分区和备份，防止数据的丢失
3. 写操作会被转发到主分区，但备份可以进行读操作的计算，增加效率
4. 一个搜索会在多台机器上分布式的进行，提升搜索效率
5. 删除和更新，都是先标记为逻辑删除，再新增数据接在后面，可以保证一定的顺序存储，提升读取效率
6. ES 的倒排索引是不可变得
   - 好处是：不需加锁，可以一直放在缓存中，也可以整块压缩节约 io 和 cpu
   - 坏处是：修改需要重新构建索引

## 最佳实践

1. 索引创建
   1. 单个 document 不要过大，会带来 IO、缓存压力
   2. 分片数量和 data client 数量保持一致
2. 文档维护
   1. 使用批量操作 bulk api
3. 搜索优化：
   1. 不要返回很大的结果集。es 被设计为搜索引擎，非常擅长返回满足查询的前几个 document。es 并不擅长返回所有数据。如果一定要这么做需要使用`scroll api`
   2. 使用`filter`效率更高，所以对于不需要搜索匹配的字段，使用`filter`更高效
   3.

# Redis

Redis 是一个 Key-Value 类型的内存数据库，通常我们用它来做缓存。

## Redis 为什么这么快

1. C 语言效率更高
2. 内存数据库，避免 I/O
3. 单线程避免了上下文切换资源竞争
4. I/O 多路复用技术处理网络 socket 连接
5. 对象压缩，如果对象小，一维结构内存小于二维结构。ziplist 紧凑型字节数组，inset 紧凑型整数数组

# Kafka
