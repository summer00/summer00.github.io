---
title: "Redis总结"
date: 2020-04-04 23:00:00 +0800
categories: [note, database]
---

- [基本使用](#%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8)
  - [数据类型](#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b)
  - [事务](#%e4%ba%8b%e5%8a%a1)
  - [Stream](#stream)
  - [安全保护](#%e5%ae%89%e5%85%a8%e4%bf%9d%e6%8a%a4)
- [原理](#%e5%8e%9f%e7%90%86)
  - [I/O 模型](#io-%e6%a8%a1%e5%9e%8b)
  - [Redis 为什么这么快](#redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab)
  - [持久化](#%e6%8c%81%e4%b9%85%e5%8c%96)
  - [过期策略](#%e8%bf%87%e6%9c%9f%e7%ad%96%e7%95%a5)
  - [LRU](#lru)
- [集群](#%e9%9b%86%e7%be%a4)
  - [主从](#%e4%b8%bb%e4%bb%8e)
  - [Redis Sentinel](#redis-sentinel)
  - [Codis](#codis)
  - [Redis Cluster](#redis-cluster)

# 基本使用

## 数据类型

| 类型         | 名称       | 应用                                                                                                          |
| ------------ | ---------- | ------------------------------------------------------------------------------------------------------------- |
| string       | 字符串     | 分布式锁，设置 key-value-ttl，考虑超时和可重入性                                                              |
| list         | 列表       | 异步消息队列                                                                                                  |
| set          | 集合       |                                                                                                               |
| zset         | 有序集合   | 延迟队列，score 为延迟时间；限流器，score 为加入时间，移除加入时间超过与之的成员，zset 大小超过限流时拒绝请求 |
| hash         | 字典       |                                                                                                               |
| setbit       | 位图       | 位图不是特殊的数据类型，而是将字符串看出 byte 数组后按位操作。用于记录 1/0 数据节约使用空间                   |
| hyperloglog  |            | 不精确的去重计数方案，标准误差 0.81%                                                                          |
| bloom filter | 布隆过滤器 | 检查一个值是否在集合里，有一定误差。当判断一个值存在时，可能不存在，但判断一个值不存在，就一定不存在          |
| redis cell   | 限流器     | 使用漏斗算法                                                                                                  |
| geo hash     | 地理模块   | 原理：将二维地理映射到一维 zset 中进行排序                                                                    |

## [事务](https://redis.io/topics/transactions)

使用`MULTI``EXEC` `DISCARD` `WATCH`

## Stream

Redis 5.0 后加入的支持多播的可持久化消息队列。它的实现参考了 Kafka 的设计，有消费组(customer group)和消费者（customer）概念，消费组通过维护游标指向已消费到的地方，消费组内的消费者是竞争关系，只会有一个消费者接到消息，消费组间相互独立。消费组会维护`pending_ids`记录没有被消费（没有收到 ack）的消息，保证至少一次的消费。stream 没有分区的概念，可以由客户端手动创建多个 stream 并设置路由规则实现分区。

```sh
xadd # 追加消息
xdel # 删除消息
xrange # 获取stream中的消息列表
xlen # 消息长度
del # 删除stream
xread # 独立消费，可以忽略消费者组概念，将stream当成普通list
xgroup create # 创建消费者组
xreadgroup # 消费组内消费
```

## 安全保护

1. 危险指令用`rename-command`设置别名，只有通过这个别名才能请求
2. 增加密码限制
3. lua 脚本安全，禁止客户输入生产 lua 脚本
4. SSL 代理，Redis 本身不支持 SSL 安全链接，需要通过代理使数据加密。官方推荐 spiped 工具

# 原理

## I/O 模型

单线程，多路复用

## Redis 为什么这么快

1. C 语言效率更高
2. 内存数据库，避免 I/O
3. 单线程避免了上下文切换资源竞争
4. I/O 多路复用技术处理网络 socket 连接
5. 对象压缩，如果对象小，一维结构内存小于二维结构。ziplist紧凑型字节数组，inset紧凑型整数数组

## 持久化

- AOF 增量日志：只记录对内存进行修改的指令，redis 先进行操作，再记录日志，日志先缓存在内存中，可通过 fsync 强刷
- rdb 快照：fork 一个子进程完成快照写入文件，用 COW（copy on write）机制保障子进程中的数据不受之后修改的影响。通常在从节点生成快照。

通常在生产环境使用混合持久话方式，因为只用 rdb 可能会丢数据，只用 AOF 效率慢。在 Redis 重启时先加载 rdb 的内容，然后再增量重放 AOF 日志。

## 过期策略

- 主节点：
  1. 维护一个设置了过期时间的 key 的字典
  2. 每秒执行一定次数（10）次的过期扫描。过期扫描并不会扫描所有的 key，会随机取 20key，将过期的删除；若过期 key 超过 1/4 就重复扫描；整个过程设置了时间上限（默认 25ms）。所以当大量`key`同时过期时可能导致节点循环删除过期`key`，以至于 25ms 不可使用，这种情况可以使用设置随机的过期时间方式避免
- 从节点：从节点并不会执行过期扫描，会同步主节点删除`key`时写入`AOF`的`del`命令

## LRU

Redis 内存超过内存使用限制时，需要执行淘汰策略，提供以下选择：

1. **noeviction**默认策略。不会继续执行写请求，读、删请求可继续执行，这样保证数据不丢失，但可能造成线上业务不能持续进行
2. **volatile-lru**淘汰设置了过期时间的 key 中最少使用的
3. **volatile-ttl**淘汰设置了过期时间的 key 中剩余寿命（ttl）值最小的
4. **volatile-random**随机淘汰设置了过期时间的 key
5. **allkey-lru**淘汰所有 key 中最少使用的
6. **allkey-random**随机淘汰所有 key

# 集群

## 主从

Redis 支持一主一从，一主多从的模式，从节点可以从主节点同步，也可以从其他从节点同步。Redis 可以通过`wait`指令指定命令的同步由异步变为同步，`wait`指令接收两个参数，节点数量`N`，等待时间`t`，表示指令需要等待`N`个节点同步完成，最长等待时间是`t`。

主从同步有两种方式：

1. 增量同步：主节点将执行的命令存在 buffer 中，buffer 是循环记录的，然后异步的将指令同步到从节点，从节点执行命令并更新自己同步的偏移量
2. 快照同步：主节点生成 rdb 快照，从节点同步 rdb 快照，完成后再同步复制 buffer。这个操作也可以不生成 rdb，主节点直接将内存中的数据通过网络传输给从节点

## Redis Sentinel

Redis Sentinel 是 Redis 集群管理的工具，类似 zookeeper 集群，客户端通过 Sentinel 链接 Redis 可以实现无感切换主节点，用以保证一定的可用性。Sentinel 切换主节点时，可能产生数据丢失，因为有些主节点执行了的命令没来的及同步到从节点。

## Codis

Codis 是 Redis 的集群方案之一。Redis 需要集群的原因：

1. 单节点内存过大会导致 rdb 变大，进一步导致主从节点全量同步时间加长，恢复时间变长
2. Redis 是单线程工作的，只能利用单 CPU

Codis 原理：

- 无状态的代理层，不改变 Redis 协议，将命令转发给接入的 Redis
- 利用分片原理管理 Redis，使用 key 的 hash 后的值取存储的位置
- 槽位和 Redis 关系通过 zookeeper 同步
- Codis 可以实现动态扩容，扩容时将原来的 key 迁移到新的槽位中，在过程中发现正在迁移的 key 有修改时，会先执行迁移，然后在新的 Redis 节点中执行命令

缺点：

1. 增加网络开销
2. 增加同步机制 zookeeper 的维护
3. 同步带来的性能消耗，以及单个集合类型的数据的大小限制
4. 非官方项目新功能同步慢

## Redis Cluster

Redis 官方集群支持，去中心化的集群，每个节点管理一部分 key，共同组成一个对等集群。

原理：

- 将所有数据划分为 16384 槽位，每个节点负责一部分槽位
- 客户端也会存一份槽位映射信息，可以计算槽位应在哪个节点，直接调用
- 若客户端槽位信息和真实槽位不一致，Redis 会返回 MOVED 指令和错误信息，客户端需要重试并纠正自己的槽位映射
- 动态扩容将槽位发生变化的 key 迁移至新的槽位；当客户端请求迁移中的 key 时，Redis 会返回 ASKING 指令和错误信息，客户端需要重试
- Cluster 中的节点支持主从，若主节点故障，会将从节点提升为主节点
- 节点下线使用 Gossip 协议，一个节点发现连接不到某个节点，广播这个信息，集群中的大部分节点承认后，再广播下线信息使所有节点承认下线
