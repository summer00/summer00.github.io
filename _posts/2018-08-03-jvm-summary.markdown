---
title:  "JVM 概览"
date:   2018-08-03 15:37:48 +0800
categories: [jvm, summary]
---

本篇是对JVM基本概念的回顾，主要参考了《深入理解Java虚拟机》。

# 内存模型

1. 线程隔离的数据区：
    * 程序计数器，指示当前线程所执行的字节码行号
    * 虚拟机栈，生命周期与线程相同。描述的是Java方法执行的模型：每个方法执行是都会创建一个栈帧用来存储局部变量表，方法出口，操作数栈，动态链接等，方法开始时入栈，结束时出栈。
    * 本地方法栈，与虚拟机栈类似，只不过执行的是Native方法

2. 线程共享的数据区：
    * 堆，存放对象实例
    * 方法区，存储虚拟机加载的类信息，常量，静态变量，及时编译后的代码等。包含运行时常量池

# 内存分配与回收

1. 分配：
    1. 检测类是否加载，若为加载先加载（这一步会确定对象需要的空间大小），加载完成后分配
    2. 分配方法：指针碰撞（空间规整），空闲列表（空间不规整）
    3. 分配中的同步：CAS OR 本地线程分配缓存

2. 对象布局： 对象头，实体数据，对齐填充

3. 回收：
    1. 回收什么样的对象：对象不再能够被访问到的时候。可达性算法，当一个对象到GC Roots（虚拟机栈中引用的对象，方法区中静态属性引用的变量，方法区中常量引用的变量，本地方法栈中引用的变量）直接没有任何链路时为不可达。主流JVM并不会挨个检查，而是会维护引用和内存的位置map。
    2. 方法：
        1. 标记清除，会产生较多碎片
        2. 复制算法，需要额外空间
        3. 标记整理，标记后移动存活对象，直接清除另端边界对象
        4. 分代收集，老年代（1,3)，新生代（2)
    3. 安全点（safepoint），虚拟机在安全点更新引用内存map（HotSpot的OopMap）。抢先式终斷（先停，发现不在安全点，运行到安全点再停，几乎不用），主动式中断（轮询标志，发现标志为争自行挂起）
    4. 安全区域（safe region），安全点扩展。若在安全区时发生GC则不做任何操作，直到出时检测是否完成根节点枚举（或整个GC）若完成则继续，没有则等待信号出。

# 类加载

1. 类的生命周期：加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载

2. 时机（主动引用时）
    1. new, getstatic, putstatic, invokestatic
    2. 反射调用
    3. 一个类被加载时，发现父类未加载，先加载父类
    4. 启动时的主类
    5. JDK7，若java.lang.invoke.MethodHandler实例最后解析的结果是REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄

3. 过程：过程包括 加载，验证，准备，解析，初始化
    1. 加载：
        1. 步骤：
            1. 获取二进制字节流
            2. 将字节流中定义静态数据结构加载到方法区运行时
            3. 生成java.lang.Class对象（堆），作为方法区的访问入口
        2. 类加载器，每个类加载器有独立的类名称空间（不同类加载器加载的类必定不相同）。类加载器通常使用，双亲委派模型
    2. 验证：
        1. 文件格式验证（魔数，版本号，常量类型。。。）
        2. 元数据验证（是否有父类，是否继承了不能继承的类。。。），保证不存在不符合Java规范的元数据
        3. 字节码验证，语意是否合法
        4. 符号引用验证（解析阶段发生）
    3. 准备：初始化类的变量到方法区，static变量初始化为0,final变量初始化为设置值
    4. 解析：符号引用替换为直接引用,可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)
        1. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可
        2. 直接引用：可以是直接指向目标的指针，相对偏移量，一个能间接定位到目标的句柄
    5. 初始化：执行类构造器`<clinit>()`方法的过程

# 虚拟机执行

1. 栈帧（stack frame）：虚拟机每执行一个方法就是一次栈帧从入栈到出栈的过程，帧栈包含了：局部变量表，操作数栈，动态连接，返回地址等（编译时已确定）。两帧栈作为虚拟机元素是完全独立的，但是大多数虚拟机会做一些优化，将上一帧栈的局部变量表与下一个帧栈的操作数栈部分重叠在一起，以共享一些数据，减少数据的复制传递。
    1. 局部变量表：以变量槽（variable solt)为最小单位，一般32位。局部变量不会赋初始值
    2. 操作数栈：先入后出。在方法执行前操作栈是空的，运行时字节码指令往数据栈中写入和提取内容（出栈/入栈）
    3. 动态连接：符号引用在类加载过程的解析阶段转化为直接引用是静态连接，运行时则是动态引用
    4. 返回地址：正常推出时使用保存的计数器值，异常退出则查询异常处理器表。
2. 方法调用：确定被调用方法的版本。Class文件编译期间不包含传统的编译过程，一切方法调用在Class文件都是符号引用
    1. 解析：类加载阶段的解析会确定内部方法和类方法的直接引用。非虚方法（内部方法，类方法，final方法）的调用过程叫解析。解析调用一定是静态的，在类转载的时候就会转为直接引用，不会延迟到运行时
    2. 分派：虚拟机通过虚方法表（稳定优化）提升效率，也使用内联缓存和类型继承关系分析（激进优化）提升效率
        1. 静态分派：依赖静态类型（外观类型）的分派，也就是重载
        2. 动态分派：根据实际类型分派方法版本，即重写。用invokevirtual指令实现。
        3. 单分派和多分派：方法的接收者和参数统称为方法的总量。java是静态多分派，动态单分派，即静态分派关系调用者和参数类型，动态只关心调用者
   
# 并发

1. 内存模型：定义在虚拟机中变量的访问规则。每个线程有自己的工作区域内存，在工作区域内存中缓存用到的主内存变量的缓存，线程对变量的操作（读取，写入）都在工作内存中进行，线程间变量值的传递均需要通过主内存。内存模型围绕如何处理并非过程中的一致性，可见性，有序性来建立的

2. 内存间的交互：Java内存模型定义了8种原子性的内存操作来完成工作内存与主内存之间的具体交互
    1. lock：主内存，把变量标识为一条线程独占
    2. unlock：主内存，把处于锁定状态的变量释放出来，释放后才可以被其他线程锁定
    3. read：主内存，把变量值从主内存传输到工作线程中
    4. load：工作内存，把read操作从主内存中得到的值放到工作内存变量副本中
    5. use：工作内存，把一个工作内存中的变量值传递给执行引擎
    6. assign：工作内存，把从执行引擎接收到的值放到工作内存变量副本中
    7. store：工作内存，把工作内存的变量的值传给主内存
    8. write：主内存，store操作得到的值放入主内存变量中

    一些规则：
    1. read/load，store/write不能单独出现
    2. 不允许丢弃最近一次assign操作，即工作区变量改变必须同步回主内存
    3. 不允许工作区变量拷贝无原因的同步，即没有调用assign
    4. 新变量只能在内存中诞生
    5. 一个变量只能被一个线程lock，这个lock是可重入的
    6. lock后会清空工作区该变量的值，需重新执行load或assign操作
    7. 没有lock不能unlock，线程不能unlock别的线程的lock
    8. unlock前必须把变量同步回主内存

    [先行发生原则](http://zouzls.github.io/2017/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8B%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99%EF%BC%88%E5%9B%9B%EF%BC%89/)：JMM中定义两项操作的偏序关系，如果操作A和操作B满足，比如操作A先行发生于操作B，那么操作B一定能看到操作A的影响。JVM定义了一些天然的先序发送原则，重排不会改变其运行顺序：单线程按代码顺序；锁释放发送在下一次获取锁之前；volatile写入发生在下一次读之前；Thread start发生于其他线程操作之前；Thread里所有操作发生在Thread中止之前；Thread `interrupt()`调用发生在线程中断处理之前；对象初始化先于`finalize()`；传递性

3. volatile：
    1. 语意：
        1. 保证可见性。在变量改变需要依赖当前值，或者需要与其他变量共同参与不变性约束时需要额外同步来保证原子性
        2. 禁止指令重排优化。通过在编译时加入一个lock前缀指令，相当于内存屏障
    2. [更多](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html)

4. java线程调度：主要有两种线程调度模式：协同（线程运行结束通知下一线程开始运行）和抢占（系统分配线程运行时间）。java使用抢占式，并且有不靠谱的优先级设定实现线程调度。

5. 状态转化：new, runable, waiting, timed waiting, blocked, terminated

# 线程安全

> 当多个线程访问一个对象的时候，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。--->《Java Concurrency In Practice》

1. 安全等级：不可变，绝对安全，相对安全(`HashTable`, `Vector`)，线程兼容(`HashMap`, `ArrayList`)，线程对立（尽量避免）

2. 实现方法：互斥同步（各种锁），非阻塞同步（CAS），天生安全（可重入代码，线程本地存储）

3. [锁优化](https://kaimingwan.com/post/java/javanei-zhi-suo-kai-xiao-you-hua-pian-xiang-suo-qing-liang-ji-suo#toc_16)：
    1. 自旋锁：锁被其他线程持有，当前等待一定时间次数的忙循环，不放弃运行时间
    2. 自适应自旋锁：旋转时间不固定，由上一次同一个锁的自旋时间和当前锁状态决定
    3. 锁消除：代码要求同步，但被检测无竞争的锁进行消除。
    4. 锁粗化：粗化对于一个锁的请求和释放
    5. 轻量级锁
    6. 偏向锁

