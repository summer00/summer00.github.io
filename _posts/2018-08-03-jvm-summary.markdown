---
layout: post
title:  "JVM 总结"
date:   2018-08-03 15:37:48 +0800
categories: [java, jvm, interview]
---

# 内存模型

1. 线程隔离的数据区：
    * 程序计数器，指示当前线程所执行的字节码行号
    * 虚拟机栈，生命周期与线程相同。描述的是Java方法执行的模型：每个方法执行是都会创建一个栈帧用来存储局部变量表，方法出口，操作数栈，动态链接等，方法开始时入栈，结束时出栈。
    * 本地方法栈，与虚拟机栈类似，只不过执行的是Native方法

2. 线程共享的数据区：
    * 堆，存放对象实例
    * 方法区，存储虚拟机加载的类信息，常量，静态变量，及时编译后的代码等。包含运行时常量池

# 内存分配与回收

1. 分配：
    1. 检测类是否加载，若为加载先加载（这一步会确定对象需要的空间大小），加载完成后分配
    2. 分配方法：指针碰撞（空间规整），空闲列表（空间不规整）
    3. 分配中的同步：CAS OR 本地线程分配缓存

2. 对象布局： 对象头，实体数据，对齐填充

3. 回收：
    1. 回收什么样的对象：对象不再能够被访问到的时候。可达性算法，当一个对象到GC Roots（虚拟机栈中引用的对象，方法区中静态属性引用的变量，方法区中常量引用的变量，本地方法栈中引用的变量）直接没有任何链路时为不可达。主流JVM并不会挨个检查，而是会维护引用和内存的位置map。
    2. 方法：
        1. 标记清除，会产生较多碎片
        2. 复制算法，需要额外空间
        3. 标记整理，标记后移动存活对象，直接清除另端边界对象
        4. 分代收集，老年代（1,3)，新生代（2)
    3. 安全点（safepoint），虚拟机在安全点更新引用内存map（HotSpot的OopMap）。抢先式终斷（先停，发现不在安全点，运行到安全点再停，几乎不用），主动式中断（轮询标志，发现标志为争自行挂起）
    4. 安全区域（safe region），安全点扩展。若在安全区时发生GC则不做任何操作，直到出时检测是否完成根节点枚举（或整个GC）若完成则继续，没有则等待信号出。

# 类加载

1. 类的生命周期：加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载

2. 时机（主动引用时）
    1. new, getstatic, putstatic, invokestatic
    2. 反射调用
    3. 一个类被加载时，发现父类未加载，先加载父类
    4. 启动时的主类
    5. JDK7，若java.lang.invoke.MethodHandler实例最后解析的结果是REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄

3. 过程：