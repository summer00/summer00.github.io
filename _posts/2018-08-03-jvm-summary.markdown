---
layout: post
title:  "JVM 总结"
date:   2018-08-03 15:37:48 +0800
categories: [java, jvm, interview]
---

# 内存模型

1. 线程隔离的数据区：
    * 程序计数器，指示当前线程所执行的字节码行号
    * 虚拟机栈，生命周期与线程相同。描述的是Java方法执行的模型：每个方法执行是都会创建一个栈帧用来存储局部变量表，方法出口，操作数栈，动态链接等，方法开始时入栈，结束时出栈。
    * 本地方法栈，与虚拟机栈类似，只不过执行的是Native方法

2. 线程共享的数据区：
    * 堆，存放对象实例
    * 方法区，存储虚拟机加载的类信息，常量，静态变量，及时编译后的代码等。包含运行时常量池

# 内存分配与回收

1. 分配：
    1. 检测类是否加载，若为加载先加载（这一步会确定对象需要的空间大小），加载完成后分配
    2. 分配方法：指针碰撞（空间规整），空闲列表（空间不规整）
    3. 分配中的同步：CAS OR 本地线程分配缓存

2. 对象布局： 对象头，实体数据，对齐填充

3. 回收：
    1. 回收什么样的对象：对象不再能够被访问到的时候。可达性算法，当一个对象到GC Roots（虚拟机栈中引用的对象，方法区中静态属性引用的变量，方法区中常量引用的变量，本地方法栈中引用的变量）直接没有任何链路时为不可达。主流JVM并不会挨个检查，而是会维护引用和内存的位置map。
    2. 方法：
        1. 标记清除，会产生较多碎片
        2. 复制算法，需要额外空间
        3. 标记整理，标记后移动存活对象，直接清除另端边界对象
        4. 分代收集，老年代（1,3)，新生代（2)
    3. 安全点（safepoint），虚拟机在安全点更新引用内存map（HotSpot的OopMap）。抢先式终斷（先停，发现不在安全点，运行到安全点再停，几乎不用），主动式中断（轮询标志，发现标志为争自行挂起）
    4. 安全区域（safe region），安全点扩展。若在安全区时发生GC则不做任何操作，直到出时检测是否完成根节点枚举（或整个GC）若完成则继续，没有则等待信号出。

# 类加载

1. 类的生命周期：加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载

2. 时机（主动引用时）
    1. new, getstatic, putstatic, invokestatic
    2. 反射调用
    3. 一个类被加载时，发现父类未加载，先加载父类
    4. 启动时的主类
    5. JDK7，若java.lang.invoke.MethodHandler实例最后解析的结果是REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄

3. 过程：过程包括 加载，验证，准备，解析，初始化
    1. 加载：
        1. 步骤：
            1. 获取二进制字节流
            2. 将字节流中定义静态数据结构加载到方法区运行时
            3. 生成java.lang.Class对象（堆），作为方法区的访问入口
        2. 类加载器，每个类加载器有独立的类名称空间（不同类加载器加载的类必定不相同）。类加载器通常使用，双亲委派模型
    2. 验证：
        1. 文件格式验证（魔数，版本号，常量类型。。。）
        2. 元数据验证（是否有父类，是否继承了不能继承的类。。。），保证不存在不符合Java规范的元数据
        3. 字节码验证，语意是否合法
        4. 符号引用验证（解析阶段发生）
    3. 准备：初始化类的变量到方法区，static变量初始化为0,final变量初始化为设置值
    4. 解析：符号引用替换为直接引用,可以认为是一些静态绑定的会被解析，动态绑定则只会在运行是进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)
        1. 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可
        2. 直接引用：可以是直接指向目标的指针，相对偏移量，一个能间接定位到目标的句柄
    5. 初始化：执行类构造器`<clinit>()`方法的过程

# 虚拟机执行

1. 栈帧（stack frame）：虚拟机每执行一个方法就是一次栈帧从入栈到出栈的过程，帧栈包含了：局部变量表，操作数栈，动态连接，返回地址等（编译时已确定）。两帧栈作为虚拟机元素是完全独立的，但是大多数虚拟机会做一些优化，将上一帧栈的局部变量表与下一个帧栈的操作数栈部分重叠在一起，以共享一些数据，减少数据的复制传递。
    1. 局部变量表：以变量槽（variable solt)为最小单位，一般32位。局部变量不会赋初始值
    2. 操作数栈：先入后出。在方法执行前操作栈是空的，运行时字节码指令往数据栈中写入和提取内容（出栈/入栈）
    3. 动态连接：符号引用在类加载过程的解析阶段转化为直接引用是静态连接，运行时则是动态引用
    4. 返回地址：正常推出时使用保存的计数器值，异常退出则查询异常处理器表。
2. 方法调用：确定被调用方法的版本。Class文件编译期间不包含传统的编译过程，一切方法调用在Class文件都是符号引用
    1. 解析：类加载阶段的解析会确定内部方法和类方法的直接引用。非虚方法（内部方法，类方法，final方法）的调用过程叫解析。解析调用一定是静态的，在类转载的时候就会转为直接引用，不会延迟到运行时
    2. 分派：虚拟机通过虚方法表（稳定优化）提升效率，也使用内联缓存和类型继承关系分析（激进优化）提升效率
        1. 静态分派：依赖静态类型（外观类型）的分派，也就是重载
        2. 动态分派：根据实际类型分派方法版本，即重写。用invokevirtual指令实现。
        3. 单分派和多分派：方法的接收者和参数统称为方法的总量。java是静态多分派，动态单分派，即静态分派关系调用者和参数类型，动态只关心调用者
   