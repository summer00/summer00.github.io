---
title: "MySQL实战"
date: 2020-04-04 23:00:00 +0800
categories: [note]
---

# SQL 优化

## `count(*)`很慢，怎么办

为什么慢：InnoDB 支持事务，采用多版本并发控制(MVCC)，每次执行`count(*)`返回的行数是不确定的，所以执行的时候会逐行读取后，累积计数。

MySQL 优化：InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 `count(*)` 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。会在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。

方案：

1. Redis 计数，由于调用 redis 时机不同，可能结果不准确
2. 单独存储，用事务的方式解决不准确的问题

## 比较`count(id)`、`count(*)`、`count(1)`、`count(字段)`

- 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
- 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。j
- 对于 count(字段) 来说：
  - 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
  - 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
- 但是`count(*)`是例外，并不会把全部字段取出来，而是专门做了优化，不取值。`count(*)` 肯定不是 null，按行累加。

所以结论是：按照效率排序的话，`count(字段)` < `count(id)` < `count(1)` =. `count(*)`

# 原理

## SQL执行过程

## 索引

### 注意：

1. 对索引字段做函数操作，不会使用索引
2. 对索引字段进行隐式的类型转换时，不会使用索引
3. 对索引字段进行隐式的字符编码转换时，不会使用索引。如两表关联，但字符集不同

## 排序

MySQL执行带排序的查询时有两种情况：
- 当没有对应的排序索引时，使用`sort_buffer`在内存中缓存所有字段进行全排序
  - 如果只取排序结果的很小的数据集（不超过`sort_buffer_size`)，会使用优先队列排序
  - 如果排序的数据量太大（大于`sort_buffer_size`）内存放不下会使用临时文件归并排序方式辅助排序
  - 如果MySQL认为单行数据太大，会使用rowid排序，rowid排序多访问了一次表的主键索引
- 当有对应顺序的索引时，直接使用索引的排序完成查询，若索引是覆盖索引会减少一次回表操作

## 日志