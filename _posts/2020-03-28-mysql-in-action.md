---
title: "MySQL实战"
date: 2020-04-04 23:00:00 +0800
categories: [note, database]
---

- [SQL 优化](#sql-%e4%bc%98%e5%8c%96)
  - [`count(*)`很慢，怎么办](#count%e5%be%88%e6%85%a2%e6%80%8e%e4%b9%88%e5%8a%9e)
  - [比较`count(id)`、`count(*)`、`count(1)`、`count(字段)`](#%e6%af%94%e8%be%83countidcountcount1count%e5%ad%97%e6%ae%b5)
  - [只返回一条记录的语句（简单）会执行很慢吗？](#%e5%8f%aa%e8%bf%94%e5%9b%9e%e4%b8%80%e6%9d%a1%e8%ae%b0%e5%bd%95%e7%9a%84%e8%af%ad%e5%8f%a5%e7%ae%80%e5%8d%95%e4%bc%9a%e6%89%a7%e8%a1%8c%e5%be%88%e6%85%a2%e5%90%97)
- [原理](#%e5%8e%9f%e7%90%86)
  - [SQL 执行过程](#sql-%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b)
  - [索引](#%e7%b4%a2%e5%bc%95)
    - [注意：](#%e6%b3%a8%e6%84%8f)
  - [排序](#%e6%8e%92%e5%ba%8f)
  - [锁](#%e9%94%81)
    - [表锁](#%e8%a1%a8%e9%94%81)
    - [行锁](#%e8%a1%8c%e9%94%81)
    - [间隙锁](#%e9%97%b4%e9%9a%99%e9%94%81)
  - [日志](#%e6%97%a5%e5%bf%97)
    - [binglog：](#binglog)
- [维护](#%e7%bb%b4%e6%8a%a4)
  - [短链接风暴：短链接太多，系统压力大时的临时解决方案](#%e7%9f%ad%e9%93%be%e6%8e%a5%e9%a3%8e%e6%9a%b4%e7%9f%ad%e9%93%be%e6%8e%a5%e5%a4%aa%e5%a4%9a%e7%b3%bb%e7%bb%9f%e5%8e%8b%e5%8a%9b%e5%a4%a7%e6%97%b6%e7%9a%84%e4%b8%b4%e6%97%b6%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88)
  - [紧急处理慢查询性能的问题](#%e7%b4%a7%e6%80%a5%e5%a4%84%e7%90%86%e6%85%a2%e6%9f%a5%e8%af%a2%e6%80%a7%e8%83%bd%e7%9a%84%e9%97%ae%e9%a2%98)
  - [高可用](#%e9%ab%98%e5%8f%af%e7%94%a8)

# SQL 优化

## `count(*)`很慢，怎么办

为什么慢：InnoDB 支持事务，采用多版本并发控制(MVCC)，每次执行`count(*)`返回的行数是不确定的，所以执行的时候会逐行读取后，累积计数。

MySQL 优化：InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 `count(*)` 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。会在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。

方案：

1. Redis 计数，由于调用 redis 时机不同，可能结果不准确
2. 单独存储，用事务的方式解决不准确的问题

## 比较`count(id)`、`count(*)`、`count(1)`、`count(字段)`

- 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
- 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。j
- 对于 count(字段) 来说：
  - 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
  - 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
- 但是`count(*)`是例外，并不会把全部字段取出来，而是专门做了优化，不取值。`count(*)` 肯定不是 null，按行累加。

所以结论是：按照效率排序的话，`count(字段)` < `count(id)` < `count(1)` =. `count(*)`

## 只返回一条记录的语句（简单）会执行很慢吗？

会，有两种情况：

1. 长时间无相应
   1. 等待锁（表级、行级）
   2. 等待 flush
2. 查询慢
   1. 扫描行多
   2. 事务长，其他链接执行了很多操作，导致回到事务开始状态做查询的时间变长

# 原理

## SQL 执行过程

## 索引

### 注意：

1. 对索引字段做函数操作，不会使用索引
2. 对索引字段进行隐式的类型转换时，不会使用索引
3. 对索引字段进行隐式的字符编码转换时，不会使用索引。如两表关联，但字符集不同

## 排序

MySQL 执行带排序的查询时有两种情况：

- 当没有对应的排序索引时，使用`sort_buffer`在内存中缓存所有字段进行全排序
  - 如果只取排序结果的很小的数据集（不超过`sort_buffer_size`)，会使用优先队列排序
  - 如果排序的数据量太大（大于`sort_buffer_size`）内存放不下会使用临时文件归并排序方式辅助排序
  - 如果 MySQL 认为单行数据太大，会使用 rowid 排序，rowid 排序多访问了一次表的主键索引
- 当有对应顺序的索引时，直接使用索引的排序完成查询，若索引是覆盖索引会减少一次回表操作

## 锁

### 表锁

### 行锁

### 间隙锁

引用极客时间 MySQL 实战中的总结的可重复读情况下的加锁规则：

> 原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。<br>
> 原则 2：查找过程中访问到的对象才会加锁。<br>
> 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。此时，行锁和间隙锁是分两步完成的。<br>
> 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。<br>
> 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。<br>

![ table t ]({{ "/assets/2020-04-12-1.png" | absolute_url }})

案例 1-唯一索引等值查询的间隙锁：若等值查询中，没有命中的行，则锁单位是 next-key lock

```sql
-- session A
begin; update t set d = d + 1 where id = 7;

-- session B
insert into t values(8,8,8); -- 阻塞，锁(5,10]区间

-- session C
insert into t values(11,8,8); -- 正常执行
update t set d=d+1 where id = 10; -- 正常执行
```

案例 2-非唯一索引等值锁：只有访问到的对象才会加锁，需注意：锁存在与索引上，若使用覆盖索引，并不会锁主键。

```sql
-- session A
select id from t where c=5 lock in share mode;

-- session B
update t set d=d+1 where id =5; -- 不会被锁，正常执行，锁的是c索引(5,10)区间

-- session C
insert into t values (7,7,7); -- 阻塞
```

案例 3-主键索引范围锁：锁扫描到的行，若出现等值根据优化 1 会退化成行锁。

案例 4-非唯一索引范围锁：锁扫描到的行，因为非唯一索引不会进行等值退化成行锁

案例 5-limit 语句加锁：锁扫描到的行，若满足了 limit 会优化不用锁到 next key

## 日志

Innodb 日志有两种，binglog(MySQL 提供) 和 redolog(引擎实现)。

### binglog：

作用：归档，主备同步，数据恢复

格式：

1. statement 直接记录语句，有可能主备不一致
2. row 记录变化的行和数据，缺点是很占空间，如果一个语句改变多条记录，row 模式也会记录多条
3. mixed 一般情况下用 statement，遇到有可能主备不一致的情况用 row

# 维护

## 短链接风暴：短链接太多，系统压力大时的临时解决方案

1. 处理掉占着链接但不工作的线程，优先断开事物外空闲链接
2. 减少连接过程的消耗，如跳过验证（风险极高）

## 紧急处理慢查询性能的问题

慢查询通常有以下三种原因造成：

1. 索引没有设计好：紧急加索引解决（ONLINE DDL）
2. SQL 语句写的不好：用`query_rewrite`方法重写语句
3. MySQL 选错索引：加`force index`

预防：测试阶段在数据库中打开慢查询日志，并设置`long_query_time`为 0，记录每条语句，分析每个语句的扫描行和使用的索引是否和设想一致，提早发现问题。

## 高可用

MySQL 通常使用主备模式实现高可用，主备同步之间会有一定的延迟，造成延迟的原因主要有：主备性能差异；备库执行其他耗时统计分析任务；大事务同步。由于延迟存在，所以切换主备时有两种策略：

1. 可靠性优先：这种方式会有不可用的时间，其中第3步比较耗时
   1. 判断备库延迟，若小于阈值，继续下一步，否则重试
   2. 将主库设置为只读状态
   3. 判断备库的延迟，直至延迟为0
   4. 将备库设置为可写状态
   5. 切换流量
2. 可用性优先：将4、5步骤调整到最开始执行，之后通过binglog补数据
