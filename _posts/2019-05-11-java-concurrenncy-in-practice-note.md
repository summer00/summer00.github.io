---
title:  "Java并发编程学习笔记"
date:   2019-05-11 15:00:00 +0800
categories: [book-note, thread]
---

# 二、 线程安全性

## 2.1 什么是线程安全

* 当多个线程同时访问某个类时，这个类始终能表现正确的行为，那么就称这个类时线程安全的。
* 在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
* 无状态的对象一定是线程安全的

## 2.2 原子性

* 竞态条件：
  * 在并发编程中，由于不恰当的执行时序而出现不正确的结果的情况；
  * 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件；
  * 大多数竞态条件的本质是，基于一种可能失效的观察结果来做出判断或者执行某个计算;
  * 要避免这个问题，就需使产生竞态条件的复合操作以原子性的形式完成

## 2.3 加锁机制

* 要保持状态的一致性，就需要在单个的原子操作中更新所有相关的状态变量
* 每个Java对象都可以做一个实现同步的锁，称为内置锁或监视锁。这种锁是互斥、可重入（重入说明锁的粒度是线程，不是调用）的锁

## 2.4 用锁保护状态

用锁保护的原则：访问共享状态的符合操作，都必须是原子性的以避免产生竞态条件。如果用同步来协调对某个变量的访问时，那么在访问这个变量的所有位置上都需要使用同步。而且当用锁协调对某个变量的访问时，在访问变量的所有位置都需要使用相同的锁。

一种常见的加锁约定是，将所有的可变状态都封装在对象的内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。例如`Vector`和其他的同步集合类。

## 2.5 活跃性与性能

决定`synchronized`块的大小需要权衡各种设计，包括安全性（不能妥协）、简单和性能。有时简单和性能会彼此冲突，但不要过早的为了性能而牺牲简单性。

# 共享对象

## 可见性

可见性问题可能导致读到失效数据。对于一个变量，没有同步的情况下，读取到的可能是一个之前的值，但如果是64位（`double``long`）类型的数据，可能高低位读取到不同的过期值的高低位。因此，在多线程环境中即便不担心失效数据问题，使用64位数据还是要做同步保护。

加锁的含义除了互斥外，还包括内存可见性。对于多线程中共享的可变变量，在同一个锁上同步可以保证每个线程都读到最新值。

### volatile
1. 语意：
   1. 保证可见性。在变量改变需要依赖当前值，或者需要与其他变量共同参与不变性约束时需要额外同步来保证原子性
   2. 禁止指令重排优化。通过在编译时加入一个 lock 前缀指令，相当于内存屏障
2. 当且仅当完全满足以下条件时，才可以使用volatile:
   1. 写入不依赖当前值，或者保证只有单线程修改这个值
   2. 该变量的值不会与其他状态变量一起纳入不变性条件
   3. 在访问变量时不需要加锁

## 线程封闭

不共享数据，仅在单线程中访问数据，例如JDBC的`Connection`对象，仅在一个线程中使用；`ThreadLocal`。