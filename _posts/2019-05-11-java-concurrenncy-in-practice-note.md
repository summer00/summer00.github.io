---
title: "Java并发编程学习笔记"
date: 2019-05-11 15:00:00 +0800
categories: [book-note, thread]
---

# 二、 线程安全性

## 2.1 什么是线程安全

- 当多个线程同时访问某个类时，这个类始终能表现正确的行为，那么就称这个类时线程安全的。
- 在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
- 无状态的对象一定是线程安全的

## 2.2 原子性

- 竞态条件：
  - 在并发编程中，由于不恰当的执行时序而出现不正确的结果的情况；
  - 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件；
  - 大多数竞态条件的本质是，基于一种可能失效的观察结果来做出判断或者执行某个计算;
  - 要避免这个问题，就需使产生竞态条件的复合操作以原子性的形式完成

## 2.3 加锁机制

- 要保持状态的一致性，就需要在单个的原子操作中更新所有相关的状态变量
- 每个 Java 对象都可以做一个实现同步的锁，称为内置锁或监视锁。这种锁是互斥、可重入（重入说明锁的粒度是线程，不是调用）的锁

## 2.4 用锁保护状态

用锁保护的原则：访问共享状态的符合操作，都必须是原子性的以避免产生竞态条件。如果用同步来协调对某个变量的访问时，那么在访问这个变量的所有位置上都需要使用同步。而且当用锁协调对某个变量的访问时，在访问变量的所有位置都需要使用相同的锁。

一种常见的加锁约定是，将所有的可变状态都封装在对象的内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。例如`Vector`和其他的同步集合类。

## 2.5 活跃性与性能

决定`synchronized`块的大小需要权衡各种设计，包括安全性（不能妥协）、简单和性能。有时简单和性能会彼此冲突，但不要过早的为了性能而牺牲简单性。

# 三、共享对象

## 可见性

可见性问题可能导致读到失效数据。对于一个变量，没有同步的情况下，读取到的可能是一个之前的值，但如果是 64 位（` double``long `）类型的数据，可能高低位读取到不同的过期值的高低位。因此，在多线程环境中即便不担心失效数据问题，使用 64 位数据还是要做同步保护。

加锁的含义除了互斥外，还包括内存可见性。对于多线程中共享的可变变量，在同一个锁上同步可以保证每个线程都读到最新值。

### volatile

1. 语意：
   1. 保证可见性。在变量改变需要依赖当前值，或者需要与其他变量共同参与不变性约束时需要额外同步来保证原子性
   2. 禁止指令重排优化。通过在编译时加入一个 lock 前缀指令，相当于内存屏障
2. 当且仅当完全满足以下条件时，才可以使用 volatile:
   1. 写入不依赖当前值，或者保证只有单线程修改这个值
   2. 该变量的值不会与其他状态变量一起纳入不变性条件
   3. 在访问变量时不需要加锁

## 线程封闭

不共享数据，仅在单线程中访问数据，例如 JDBC 的`Connection`对象，仅在一个线程中使用；`ThreadLocal`。

## 不变性

不可变的对象一定是线程安全的。

一个变量被声明成`final`的表示它的值不能被改变。如果它是一个引用表示不能被重新指定指向的对象，但是其对象的值是可以改变的。我们必须初始化`final`变量，它只能被初始化一次。

## 安全发布

对象的安全发布需求取决与它的可变性：

1. 不可变对象可以通过任意机制发布
2. 事实不可变对象必须通过安全方式来发布
3. 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来

在并发程序中使用和共享对象时，可以通过以下策略安全地共享变量：

1. 线程封闭：线程封闭对象只能由一个线程拥有
2. 只读共享：没有任何同步机制下，多个线程只读一个对象是安全的，任何线程都不能修改它
3. 线程安全的共享：线程安全对象在其内部实现同步，多线程通过对象的接口访问，而不需要进一步同步
4. 保护对象：通过持有特定的锁来访问

# 四、对象组合

## 设计线程安全的类

在设计线程安全的类时，需要包含以下三个基本要素：

1. 找出构成对象状态的所有变量
2. 找出约束变量的不变性条件
3. 建立对象状态的并发访问管理策略

方法：
- 实施封闭
  - 封装简化了线程安全类的实现过程，将数据封装在对象的内部，可以将数据的访问限制在对象的方法上，从而更容易的确保线程在访问数据时总能持有正确的锁。
- 实施委托
  - 如果一个类是由多个独立的线程安全的状态变量组成，并且所有的操作都不包含无效状态的转换，那么可以将线程安全性委托给底层的状态变量
  - 如果类中的线程安全状态不是彼此独立的，且含有复合操作，那么仅靠委托并不能实现线程安全
- 发布底层变量